// Copyright 2017 Semmle Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the License for the specific language governing
// permissions and limitations under the License.

/**
 * A utility library for detecting the output of popular module bundlers.
 */

import javascript

/**
 * An integer literal in decimal notation.
 */
class DecimalLiteral extends NumberLiteral {
  DecimalLiteral() { getValue().regexpMatch("[0-9]+") }
}

/**
 * Does `oe` look like it was produced by Browserify (http://browserify.org/)?
 *
 * Generally, Browserify's output looks like this:
 *
 * ```javascript
 * (function e(t, n, r) {
 *   // module loader code
 * }({
 *   1: [ function(require, module, exports) {
 *          require("./dep1");
 *          require("./dep2);
 *          // ...
 *        }, { "./dep1": 2, "./dep2": 4, ... } ],
 *   2: [ function(require, module, exports) {
 *          // code for module "dep1"
 *        }, { ... } ],
 *   3: ...,
 *   4: [ function(require, module, exports) {
 *          // code for module "dep2"
 *        }, { ... } ],
 *   ...
 * }, {}, [1]);
 * ```
 */
predicate isBrowserifyBundle(ObjectExpr oe) {
  // ensure that there is at least one property
  forex (Property p | p = oe.getAProperty() |
    // and each property looks like a packed module
    isBrowserifyBundledModule(p)
  ) and
  // the whole object must be passed to the module loader function
  exists (CallExpr ce | ce.getCallee().stripParens() instanceof Function |
    // the module loader function always has three arguments
    ce.getNumArgument() = 3 and
    // the first of which is the bundle
    ce.getArgument(0) = oe
  )
}

/**
 * Does `p` look like a bundled module generated by Browserify?
 */
private predicate isBrowserifyBundledModule(Property p) {
  // the key must be a decimal literal
  p.(ValueProperty).getNameExpr() instanceof DecimalLiteral and
  // the value must look like a bundled up module
  exists (ArrayExpr ae | ae = p.getInit() |
    // first element must be a function (known as the module factory function)
    isBrowserifyModuleFactoryFunction(ae.getElement(0)) and
    // second element must be an object literal listing dependencies
    isBrowserifyDependencyMap(ae.getElement(1))
  )
}

/**
 * Does `factory` look like a Browserify-generated module factory function?
 *
 * We check that each parameter is named one of `require`, `module` or `exports`,
 * and that there is at least one of them. We also recognise `_dereq_` instead
 * of `require` to account for additional mangling by derequire
 * (https://www.npmjs.com/package/derequire).
 *
 * Currently, Browserify always generates all three parameters, but this
 * might well change in future, so we don't rely on it
 */
private predicate isBrowserifyModuleFactoryFunction(FunctionExpr factory) {
  forex (Parameter parm | parm = factory.getAParameter() |
    parm.(SimpleParameter).getName().regexpMatch("require|module|exports|_dereq_")
  )
}

/**
 * Does `deps` look like a Browserify-generated dependency map for a bundled module?
 */
private predicate isBrowserifyDependencyMap(ObjectExpr deps) {
  // there may be no dependencies, hence `forall` instead of `forex`
  forall (Property dep | dep = deps.getAProperty() |
    // each key must be a string literal
    dep.(ValueProperty).getNameExpr() instanceof StringLiteral and
    // and each value must be a decimal literal
    dep.getInit() instanceof DecimalLiteral
  )
}


/**
 * Does `ae` look like it was produced by Webpack (https://webpack.github.io/)?
 *
 * Generally, Webpack's output looks like this:
 *
 * ```javascript
 * (function(modules) {
 *    // module loader code
 * })([
 *   function(module, exports, __webpack_require__) {
 *     __webpack_require(1);
 *     // ...
 *   },
 *   function(module, exports) {
 *     // does not use __webpack_require
 *   }
 * ]);
 * ```
 */
predicate isWebpackBundle(ArrayExpr ae) {
  // ensure that there is at least one element
  forex (Expr elt | elt = ae.getAnElement() |
    // every element is a function
    exists (FunctionExpr factory | factory = elt |
      // parameters must be named either 'module' or 'exports', or
      // some string containing 'webpack_require';
      // note: at the moment, the 'require' function is always called
      // '__webpack_require__' even if the function declares a variable of
      // that name; this is probably a bug and may change, so we don't match
      // the exact name
      forex (Parameter parm | parm = factory.getAParameter() |
        parm.(SimpleParameter).getName().regexpMatch("module|exports|.*webpack_require.*")
      )
    )
  ) and
  // the whole array must be passed to a module loader function
  exists (CallExpr ce | ce.getCallee().stripParens() instanceof Function |
    // which is the bundle
    ce.getArgument(0) = ae
  )
}

/**
 * Does the given toplevel contain code that looks like the output of a module bundler?
 */
predicate isBundle(TopLevel tl) {
  exists (Expr e | e.getTopLevel() = tl |
    isBrowserifyBundle(e) or
    isWebpackBundle(e)
  )
}